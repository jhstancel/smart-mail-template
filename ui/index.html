<!doctype html>
<html lang="en" data-theme="light-minimal">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Smart Mail</title>
<style>
/* Parts card: remove any phantom bar under the title */
.kv:has(#partsCardBody) .parts-header {
  margin-top: 0;
  padding: 0;
  background: transparent;
  min-height: 0;  /* prevents a â€˜barâ€™ look */
}

/* Tighten spacing between title and header */
.kv:has(#partsCardBody) label + #partsCardBody { margin-top: 0; }
.kv:has(#partsCardBody) .parts-header { margin-bottom: 6px; }

/* Ensure no stray backgrounds in the header cells */
.kv:has(#partsCardBody) .parts-header > * {
  background: transparent !important;
}

.card-b {
  background: var(--card-bg1);
  border-radius: 12px;
  padding: 12px;
}

/* Parts inputs: same bg as card/page + rounded */
.parts-row .parts-input{
  background: transparent;        /* lets the card/page bg show through */
  border-radius: 12px;            /* rounded rectangles */
  height: 44px;                   /* slightly taller, like other fields */
  width: 100%;
}
.parts-row .parts-qty{
  text-align: center;
}

.parts-header{                    /* keep header grid tidy */
  display:grid;
  grid-template-columns: 1fr 1fr 40px;
  gap:12px;
  align-items:center;
  margin-bottom:6px;
}
.parts-row{
  display:grid;
  grid-template-columns: 1fr 1fr 40px;
  gap:12px;
  align-items:center;
  margin:8px 0;
}

/* icon buttons (minus + plus) â€“ unchanged size, just here for completeness */
.icon-btn{
  width:40px; height:40px; border-radius:999px;
  display:flex; align-items:center; justify-content:center;
  background:#fff; font-size:18px; line-height:1; cursor:pointer;
}
.parts-minus{ border:1px solid rgba(255,100,100,.45); }
.parts-plus{  border:1px solid rgba(80,180,120,.45); color:#2f855a; }
.parts-minus:hover{ border-color: rgba(255,80,80,.8); }
.parts-plus:hover{  border-color: rgba(60,160,100,.8); color:#276749; }

/* Equal-width inputs + icon buttons */
.parts-header{
  display:grid;
  grid-template-columns: 1fr 1fr 40px;  /* equal widths, fixed icon column */
  gap:12px;
  align-items:center;
  margin-bottom:6px;
}
.parts-row{
  display:grid;
  grid-template-columns: 1fr 1fr 40px;  /* equal widths */
  gap:12px;
  align-items:center;
  margin:6px 0;
}
.parts-input{ height:40px; width:100%; }
.parts-qty{ text-align:center; }

/* Shared icon button */
.icon-btn{
  width:40px; height:40px;
  border-radius:999px;
  display:flex; align-items:center; justify-content:center;
  background:#fff;
  cursor:pointer;
  font-size:18px; line-height:1;
  user-select:none;
}

/* â€“ (remove) = soft red ring */
.parts-minus{
  border:1px solid rgba(255,100,100,.45);
}
.parts-minus:hover{ border-color: rgba(255,80,80,.8); }

/* + (add) = soft green ring */
.parts-plus{
  border:1px solid rgba(80,180,120,.45);
  color:#2f855a;
  background:#fff;
}
.parts-plus:hover{
  border-color: rgba(60,160,100,.8);
  color:#276749;
}

/* Position of the plus row */
.parts-plus-row{ margin-top:8px; }

  /* ===== THEME VARIABLES ===== */
  :root{
    --bg:#ffffff;            /* default: light-minimal */
    --glass:#ffffffcc;
    --ink:#0b1220;
    --muted:#5b677a;
    --accent:#2457ff;
    --accent-2:#3ba3ff;
    --ok:#2ecc71; --warn:#ffb84d; --bad:#ff6b6b;
    --panel-border: rgba(12,16,24,.07);
    --card-bg1: rgba(0,0,0,.02);
    --card-bg2: rgba(0,0,0,.01);
    --card-border: rgba(12,16,24,.08);
    --btn-grad1:#255fff; --btn-grad2:#1846cf;
    --shadow-1: 0 10px 24px rgba(0,0,0,.10);
    --shadow-2: 0 16px 44px rgba(0,0,0,.12);
    --focus-ring: rgba(36,87,255,.14);
    --focus-border: rgba(36,87,255,.55);
  }
  /* Dark-Minimal */
  body[data-theme="dark-minimal"]{
    --bg:#0e1320; --glass:#151c2acc; --ink:#e9eef7; --muted:#a7b3c5;
    --accent:#7ab8ff; --accent-2:#8ee3ff; --panel-border: rgba(255,255,255,.08);
    --card-bg1: rgba(255,255,255,.06); --card-bg2: rgba(255,255,255,.02);
    --card-border: rgba(255,255,255,.10);
    --btn-grad1:#1b67ff; --btn-grad2:#124bcb;
    --shadow-1: 0 10px 30px rgba(0,0,0,.35); --shadow-2: 0 18px 44px rgba(0,0,0,.5);
    --focus-ring: rgba(122,184,255,.10); --focus-border: rgba(122,184,255,.45);
  }
  /* Cosmic (original) */
  body[data-theme="cosmic"]{
    --bg:#0b0f16; --glass:#0f1623cc; --ink:#e9eef7; --muted:#a7b3c5;
    --accent:#7ab8ff; --accent-2:#8ee3ff; --panel-border: rgba(255,255,255,.08);
    --card-bg1: rgba(255,255,255,.06); --card-bg2: rgba(255,255,255,.02);
    --card-border: rgba(255,255,255,.10);
    --btn-grad1:#1b67ff; --btn-grad2:#124bcb;
    --shadow-1: 0 10px 30px rgba(0,0,0,.35); --shadow-2: 0 18px 44px rgba(0,0,0,.5);
    --focus-ring: rgba(122,184,255,.10); --focus-border: rgba(122,184,255,.45);
  }
  /* Dusk Gradient (soft peach/purple) */
  body[data-theme="dusk-gradient"]{
    --bg: linear-gradient(180deg,#fff4ec,#f3f4ff);
    --glass:#ffffffcc; --ink:#0b1220; --muted:#586175;
    --accent:#7a5cff; --accent-2:#ff8fb3; --panel-border: rgba(12,16,24,.07);
    --card-bg1: rgba(0,0,0,.02); --card-bg2: rgba(0,0,0,.01);
    --card-border: rgba(12,16,24,.08);
    --btn-grad1:#6c55ff; --btn-grad2:#4a3ee6; --shadow-1: 0 10px 24px rgba(0,0,0,.10);
    --shadow-2: 0 16px 44px rgba(0,0,0,.12); --focus-ring: rgba(108,85,255,.16);
    --focus-border: rgba(108,85,255,.5);
  }
  /* Forest Mist (cool green/teal) */
  body[data-theme="forest-mist"]{
    --bg: linear-gradient(180deg,#eef8f4,#edf6ff);
    --glass:#ffffffcc; --ink:#0a1612; --muted:#4b5f5a;
    --accent:#1e9e7a; --accent-2:#3cb8a0; --panel-border: rgba(12,16,24,.07);
    --card-bg1: rgba(0,0,0,.02); --card-bg2: rgba(0,0,0,.01);
    --card-border: rgba(12,16,24,.08);
    --btn-grad1:#1e9e7a; --btn-grad2:#167a5e; --shadow-1: 0 10px 24px rgba(0,0,0,.10);
    --shadow-2: 0 16px 44px rgba(0,0,0,.12); --focus-ring: rgba(30,158,122,.16);
    --focus-border: rgba(30,158,122,.5);
  }

  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; color:var(--ink); background:var(--bg);
    font:15px/1.5 Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto;
    overflow-x:hidden;
  }
  /* Parts editor polish */
.parts-editor { display:flex; flex-direction:column; gap:8px; }
.parts-table { width:100%; border-collapse:separate; border-spacing:0 6px; }
.parts-table th, .parts-table td { text-align:left; padding:6px; }
.parts-table input.input { width:100%; }
.btn-mini{ border:1px solid var(--card-border); background:linear-gradient(180deg, var(--card-bg1), var(--card-bg2)); border-radius:10px; padding:6px 8px; cursor:pointer }
.btn-mini.danger{ border-color: rgba(255,100,100,.5); }
.parts-rows  { width:100%; border-collapse:separate; border-spacing:0 8px; }
.parts-rows td { padding:0; }
.parts-rows .cell { display:flex; align-items:center; gap:10px; }
.parts-rows input.input { width:100%; }
.parts-minus { border:1px solid rgba(255,100,100,.5); border-radius:12px; padding:4px 8px; background:transparent; cursor:pointer; }
.parts-plus  { border:1px solid var(--card-border); border-radius:14px; padding:6px 10px; background:linear-gradient(180deg, var(--card-bg1), var(--card-bg2)); cursor:pointer; }
.parts-plus-row td { padding-top:4px; }
.parts-label { font-weight:700; }

  /* Starfield */
  canvas#stars{position:fixed; inset:0; z-index:-3;}
  .glow-veil{position:fixed; inset:-10vmax; z-index:-2;
    background: radial-gradient(60vmax 60vmax at 20% -10%, rgba(120,170,255,.12), transparent 60%),
                radial-gradient(50vmax 50vmax at 110% 20%, rgba(120,220,255,.10), transparent 55%),
                radial-gradient(40vmax 35vmax at 40% 120%, rgba(160,140,255,.08), transparent 60%);
    filter: blur(40px); pointer-events:none;
  }
  /* Hide cosmic effects for non-cosmic themes */
  body:not([data-theme="cosmic"]) canvas#stars,
  body:not([data-theme="cosmic"]) .glow-veil{ display:none; }

  .wrap{max-width:1080px; margin:48px auto; padding:0 20px}
  .panel{
    background:var(--glass);
    -webkit-backdrop-filter: blur(12px);
    backdrop-filter: blur(12px);
    border:1px solid var(--panel-border);
    border-radius:18px;
    box-shadow: var(--shadow-1);
    padding:18px;
  }
  .title{font-weight:800; letter-spacing:.3px; margin:0 0 10px 0; font-size:20px}
  .subtitle{color:var(--muted); margin-top:2px; font-size:13px}

  /* Intent grid */
  .intent-grid{ display:grid; gap:12px; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); margin-top:12px; }
  .intent-card{ position:relative; padding:14px; cursor:pointer; border-radius:16px;
    background:linear-gradient(180deg, var(--card-bg1), var(--card-bg2));
    border:1px solid var(--card-border); box-shadow: var(--shadow-1);
    transition: transform .35s cubic-bezier(.2,.7,.2,1), box-shadow .35s ease, border-color .25s ease, filter .25s ease;
    transform-origin:center; overflow:hidden; text-align:left; }
  .intent-card:hover{ transform: translateY(-2px) scale(1.03); box-shadow: var(--shadow-2); border-color: color-mix(in srgb, var(--accent) 25%, transparent); filter: saturate(1.02); }
  .intent-card.active{ transform: translateY(-1px) scale(1.01); box-shadow: var(--shadow-2); border-color: color-mix(in srgb, var(--accent) 25%, transparent); }
  .intent-card.active::after{ content:""; position:absolute; inset:0; border-radius:16px; pointer-events:none; padding:1px;
    background: linear-gradient(120deg, color-mix(in srgb, var(--accent) 0%, transparent) 0%, color-mix(in srgb, var(--accent) 65%, transparent) 12%, color-mix(in srgb, var(--accent) 0%, transparent) 30%) border-box;
    -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
    -webkit-mask-composite: xor; mask-composite: exclude; animation: edgeGlide 3.6s linear infinite; }
  @keyframes edgeGlide { 0% { background-position: 0% 0% } 100% { background-position: 200% 0% } }

  .intent-name{font-weight:800; margin:0 0 6px; letter-spacing:.2px}
  .intent-desc{color:var(--muted); font-size:13px}

  .stage{ margin-top:16px; overflow:hidden; transition: height .45s ease, opacity .45s ease, margin .45s ease; }
  .stage.hidden{ height:0; opacity:0; margin:0; }

  label{display:block; margin:8px 0 6px; font-weight:700; letter-spacing:.2px}
  input[type=text], input[type=email], textarea, select{
    width:100%; color:var(--ink); background:color-mix(in srgb, var(--bg) 90%, black 10%);
    border:1px solid var(--panel-border); border-radius:12px; padding:12px 14px; outline:none;
    box-shadow: 0 0 0 0 rgba(0,0,0,0);
    transition: box-shadow .25s ease, border-color .25s ease, background .25s ease, transform .25s ease;
  }
:root {
  --accent: #639cff;
}

  /* Native date input tweaks */
  input[type="date"]{
    width:100%; color:var(--ink);
    background:color-mix(in srgb, var(--bg) 90%, black 10%);
    border:1px solid var(--panel-border);
    border-radius:12px; padding:12px 14px; outline:none;
    box-shadow: 0 0 0 0 rgba(0,0,0,0);
    transition: box-shadow .25s ease, border-color .25s ease, background .25s ease, transform .25s ease;
    font:inherit;
  }
  input[type="date"]:focus{
    border-color: var(--focus-border);
    box-shadow: 0 0 0 6px var(--focus-ring);
    background: color-mix(in srgb, var(--bg) 70%, white 30%);
    transform: translateZ(0) scale(1.01);
  }
  input[type="date"]::-webkit-calendar-picker-indicator{
    cursor:pointer; opacity:.9;
    filter: drop-shadow(0 0 0 rgba(0,0,0,0));
  }
  @-moz-document url-prefix(){
    input[type="date"]{ padding-right: 12px; }
  }

  input:focus, textarea:focus, select:focus{
    border-color: var(--focus-border); box-shadow: 0 0 0 6px var(--focus-ring); background: color-mix(in srgb, var(--bg) 70%, white 30%);
    transform: translateZ(0) scale(1.01);
  }
  textarea{min-height:90px; resize:vertical}

  .row{display:grid; gap:12px; grid-template-columns:1fr 1fr}
  .kvs{display:grid; gap:10px; grid-template-columns:repeat(auto-fit,minmax(220px,1fr));}

  /* âœ¨ Pretty, consistent field boxes */
  .kv{
    display:flex; flex-direction:column; gap:6px;
    padding:12px; border-radius:14px;
    background:linear-gradient(180deg, var(--card-bg1), var(--card-bg2));
    border:1px solid var(--card-border);
  }

  .muted{color:var(--muted); font-size:12px}
  .pill{padding:4px 10px; border-radius:999px; border:1px solid var(--panel-border); background:color-mix(in srgb, var(--bg) 85%, white 15%);}

  .btn{ background: linear-gradient(180deg, var(--btn-grad1), var(--btn-grad2)); color:white; font-weight:900; letter-spacing:.3px; border:none; border-radius:12px;
    padding:11px 14px; cursor:pointer; box-shadow: 0 10px 30px color-mix(in srgb, var(--btn-grad1) 35%, transparent), 0 0 40px color-mix(in srgb, var(--btn-grad1) 18%, transparent) inset;
    transition: transform .15s ease, box-shadow .25s ease, filter .15s ease; }
  .btn:hover{ transform: translateY(-1px) scale(1.03); filter: brightness(1.03); }
  .btn.secondary{ background:linear-gradient(180deg, var(--card-bg1), var(--card-bg2)); color:var(--ink); border:1px solid var(--card-border); box-shadow:none }

  /* Toast success state (temporary) */
  .btn.toast{
    background: linear-gradient(180deg, var(--ok), color-mix(in srgb, var(--ok) 80%, black 20%)) !important;
    box-shadow: 0 10px 30px color-mix(in srgb, var(--ok) 35%, transparent), 0 0 40px color-mix(in srgb, var(--ok) 18%, transparent) inset !important;
  }

  .out{white-space:pre-wrap; background:color-mix(in srgb, var(--bg) 90%, black 10%); border:1px solid var(--panel-border); border-radius:12px; padding:12px;}
  .hr{height:1px; background:linear-gradient(90deg, transparent, var(--panel-border), transparent); margin:14px 0 10px 0; border:none;}
  .inline{display:flex; gap:8px; align-items:center; flex-wrap:wrap}

  @media (prefers-reduced-motion: reduce) { .glow-in { animation: none !important; } }
  .glow-in { animation: glowIn 700ms ease-out; }
  @keyframes glowIn { 0% { background: color-mix(in srgb, var(--accent) 14%, transparent) } 100% { background: transparent; } }

  #outSubject, #outBody { min-height: 42px; }
  #outBody .line{ margin: 2px 0; }
  .toggle { display:flex; align-items:center; gap:8px; cursor:pointer; }

  /* ===== Minimal theme dampening (no/low animation) ===== */
  body[data-theme$="minimal"] .intent-card,
  body[data-theme$="minimal"] .btn,
  body[data-theme$="minimal"] input,
  body[data-theme$="minimal"] textarea { transition: none; }
  body[data-theme$="minimal"] .intent-card:hover { transform:none; box-shadow: var(--shadow-1); filter:none; }

  /* ===== Settings Gear (upper-right) ===== */
  .settings{ position:fixed; top:12px; right:12px; z-index:20; }
  .settings-btn{
    display:flex; align-items:center; justify-content:center; gap:8px;
    width:38px; height:38px; border-radius:12px; border:1px solid var(--panel-border);
    background:color-mix(in srgb, var(--bg) 85%, white 15%);
    box-shadow: var(--shadow-1); cursor:pointer;
    transition: transform .15s ease, box-shadow .25s ease;
    position:relative;
  }
  .settings-btn:hover{ transform: translateY(-1px); box-shadow: var(--shadow-2); }
  .settings-menu{
    margin-top:8px; min-width:260px; max-width:320px;
    display:none; flex-direction:column; gap:8px;
    padding:10px; border-radius:14px; border:1px solid var(--panel-border);
    background:var(--glass); box-shadow: var(--shadow-2);
  }
  .settings-menu.open{ display:flex; }
  .settings-item{
    display:flex; align-items:center; justify-content:space-between; gap:10px;
    border:1px solid var(--card-border); border-radius:12px;
    background:linear-gradient(180deg, var(--card-bg1), var(--card-bg2));
    padding:10px 12px; cursor:pointer;
  }
  .settings-item .label{ font-weight:700; }
  .settings-item .hint{ color:var(--muted); font-size:12px; }

  .settings-subpanel{ overflow:hidden; height:0; opacity:0; transition: height .35s ease, opacity .35s ease, margin .35s ease; margin:0; }
  .settings-subpanel.open{ height:auto; opacity:1; margin-top:6px; }
  .settings-row{ display:flex; align-items:center; gap:10px; }
  .settings-row select{ min-width:200px; }

  .chev{ width:14px; height:14px; transition: transform .25s ease; }
  .rot90{ transform: rotate(90deg); }

  /* ===== Easter Egg UI Elements ===== */

  /* Gear splash tooltip */
  .splash-tip{
    position:absolute; top:46px; right:0;
    background:var(--glass); border:1px solid var(--panel-border);
    box-shadow: var(--shadow-2); border-radius:10px; padding:8px 10px;
    white-space:nowrap; font-weight:800; font-size:12px; color:var(--ink);
    opacity:0; transform: translateY(-6px); pointer-events:none; transition: opacity .2s ease, transform .2s ease;
  }
  .splash-tip.show{ opacity:1; transform: translateY(0); }

  /* Rabbit + portal */
  .rabbit{ position:fixed; bottom:18px; left:-40px; width:18px; height:18px; border-radius:50%;
    background:white; box-shadow: 0 0 16px rgba(255,255,255,.8); z-index:30; animation: hop 1.6s ease-in-out forwards; }
  @keyframes hop{
    0%{ transform: translateX(0) translateY(0) }
    20%{ transform: translateX(20vw) translateY(-40px) }
    40%{ transform: translateX(40vw) translateY(0) }
    60%{ transform: translateX(60vw) translateY(-36px) }
    80%{ transform: translateX(80vw) translateY(0) }
    100%{ transform: translateX(105vw) translateY(-48px) }
  }
  .portal{ position:fixed; right:10%; bottom:60px; width:0; height:0; border-radius:50%; z-index:31;
    background: radial-gradient(circle at 50% 50%, rgba(120,220,255,.9), rgba(120,180,255,.25) 40%, transparent 60%);
    filter: blur(2px); animation: portalOpen .6s ease-out forwards; }
  @keyframes portalOpen { to{ width:160px; height:160px; box-shadow: 0 0 60px rgba(120,200,255,.5) inset; } }
  .portal-msg{
    position:fixed; right:calc(10% + 14px); bottom:150px; z-index:32; max-width:320px;
    background:var(--glass); border:1px solid var(--panel-border); padding:10px 12px; border-radius:12px;
    font-weight:800; box-shadow: var(--shadow-2);
    animation: fadeIn .25s ease-out both;
  }
  @keyframes fadeIn { from{ opacity:0; transform: translateY(6px) } to{ opacity:1; transform: translateY(0) } }

  /* Corruption overlay + effects */
  .corrupt-overlay{
    position:fixed; inset:0; z-index:40; pointer-events:none;
    background:
      repeating-linear-gradient(0deg, rgba(255,0,0,.03), rgba(0,255,255,.03) 2px, transparent 3px, transparent 6px),
      radial-gradient(60vmax 60vmax at 50% -10%, rgba(255,255,255,.06), transparent 60%);
    mix-blend-mode: overlay; opacity:.0; transition:opacity .25s ease;
  }
  body.corrupting .corrupt-overlay{ opacity:.9; animation: jitter .15s infinite alternate; }
  body.corrupting{ filter: hue-rotate(20deg) contrast(1.1) saturate(1.2); }
  @keyframes jitter{
    from{ transform: translate(-1px,0) skewX(.3deg) }
    to  { transform: translate(1px,0)  skewX(-.3deg)}
  }

  .flash{ position:fixed; inset:0; background:white; z-index:50; opacity:0; pointer-events:none; }
  .flash.show{ animation: flashbang .7s ease-out both; }
  @keyframes flashbang{ 0%{opacity:0} 20%{opacity:1} 100%{opacity:0} }

  .buffer{
    position:fixed; inset:0; background:color-mix(in srgb, var(--bg) 70%, black 30%); z-index:45; display:none;
    align-items:center; justify-content:center; color:var(--ink);
  }
  .buffer.show{ display:flex; }
  .buffer-card{
    background:var(--glass); border:1px solid var(--panel-border); border-radius:16px; padding:18px; width:min(520px, 90vw);
    box-shadow: var(--shadow-2); text-align:center;
  }
  .bar{ height:10px; border-radius:10px; background:color-mix(in srgb, var(--bg) 85%, white 15%); overflow:hidden; border:1px solid var(--panel-border); }
  .bar > i{ display:block; height:100%; width:0%; background: linear-gradient(90deg, var(--accent), var(--accent-2)); }
  /* Printer reload effect */
  .print-mask{ position:fixed; inset:0; background:var(--bg); z-index:44; display:none; }
  .print-mask.show{ display:block; animation: printReveal 2.4s steps(24) forwards .2s; }
  @keyframes printReveal{
    from{ clip-path: inset(0 0 100% 0); }
    to{   clip-path: inset(100% 0 0 0); }
  }
  .print-line{
    position:fixed; left:0; right:0; top:0; height:2px; z-index:46; background: color-mix(in srgb, var(--ink) 40%, transparent);
    display:none;
  }
  .print-line.show{ display:block; animation: lineSweep 2.4s linear forwards .2s; }
  @keyframes lineSweep{
    from{ transform: translateY(0) }
    to{ transform: translateY(100vh) }
  }

  /* ðŸš« Make the "Required Fields" helper invisible without removing it */
  #fieldsHint{ display:none !important; }
</style>
</head>
<body>
<!-- Settings Gear (upper-right) -->
<div class="settings" id="settings">
  <button id="settingsBtn" class="settings-btn" aria-haspopup="true" aria-expanded="false" aria-controls="settingsMenu" title="Settings">
    <!-- Gear Icon -->
    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
      <path d="M12 15.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7Z" stroke="currentColor" stroke-width="1.8"/>
      <path d="M19.4 13.1a7.52 7.52 0 0 0 .05-2.21l2.06-1.6-2-3.46-2.49 .57a7.52 7.52 0 0 0-1.92-1.11l-.5-2.53H9.39l-.5 2.53a7.52 7.52 0 0 0-1.92 1.1l-2.49-.56-2 3.46 2.06 1.6a7.52 7.52 0 0 0 0 2.22l-2.06 1.6 2 3.46 2.49-.57c.6 .47 1.24 .85 1.93 1.12l.5 2.53h4.31l.5-2.53c.68-.27 1.33-.65 1.92-1.12l2.49.57 2-3.46-2.06-1.6Z" stroke="currentColor" stroke-width="1.4"/>
    </svg>
    <div id="splashTip" class="splash-tip" role="status" aria-live="polite"></div>
  </button>
  <div id="settingsMenu" class="settings-menu panel" role="menu" aria-label="Settings">
    <!-- Item: Theme -->
    <div class="settings-item" data-item="theme" role="menuitem" tabindex="0">
      <div>
        <div class="label">Theme</div>
        <div class="hint">Light Minimal, Dark Minimal, Cosmic, Dusk, Forest</div>
      </div>
      <svg class="chev" viewBox="0 0 24 24"><path fill="currentColor" d="M9 6l6 6-6 6"/></svg>
    </div>
    <div id="subTheme" class="settings-subpanel">
      <div class="settings-row">
        <label for="themeSelect" class="muted" style="min-width:90px">Preset</label>
        <select id="themeSelect" aria-label="Theme">
          <option value="light-minimal">Light Minimal (Default)</option>
          <option value="dark-minimal">Dark Minimal</option>
          <option value="cosmic">Cosmic</option>
          <option value="dusk-gradient">Dusk Gradient</option>
          <option value="forest-mist">Forest Mist</option>
        </select>
      </div>
    </div>

    <!-- Item: Typing Animation -->
    <div class="settings-item" data-item="typing" role="menuitem" tabindex="0">
      <div>
        <div class="label">Compose Animation</div>
        <div class="hint">Enable or disable live typing effect</div>
      </div>
      <svg class="chev" viewBox="0 0 24 24"><path fill="currentColor" d="M9 6l6 6-6 6"/></svg>
    </div>
<div id="subTyping" class="settings-subpanel">
  <div class="settings-row" style="justify-content:space-between; margin:8px 0">
    <div>
      <div class="label">Live Output Preview</div>
      <div class="hint">Auto-fill subject &amp; body while typing</div>
    </div>
    <label class="toggle" aria-label="Enable Live Output Preview">
      <input id="livePreview" type="checkbox" /> Live Preview
    </label>
  </div>
  <label class="toggle" for="liveCompose" style="margin-top:2px">
    <input id="liveCompose" type="checkbox" checked /> Compose Live
  </label>
  <p class="muted" style="margin:6px 0 0">Note: Minimal themes dampen most animations.</p>
</div>

<!-- new Global Defaults section -->
<div class="settings-item" data-item="defaults" role="menuitem" tabindex="0">
  <div>
    <div class="label">Global Defaults</div>
    <div class="hint">Set Ship Address & FedEx Account defaults</div>
  </div>
  <svg class="chev" viewBox="0 0 24 24"><path fill="currentColor" d="M9 6l6 6-6 6"/></svg>
</div>
<div id="subDefaults" class="settings-subpanel">
  <div class="label" style="margin:8px 0 6px">Global Defaults</div>
  <div class="hint" style="margin:-2px 0 10px">Fill these once and weâ€™ll prefill matching fields.</div>

  <label style="display:block; font-weight:600; margin:8px 0 4px">Ship Address</label>
  <input id="g_shipAddress" type="text" placeholder="1457 Merrimon Ave. Asheville, NC 28804">


  <div class="inline" style="margin-top:10px">
    <label class="toggle"><input id="g_save" type="checkbox"> Save for this browser</label>
    <button id="g_apply" class="btn secondary" type="button">Apply</button>
    <button id="g_clear" class="btn secondary" type="button">Clear</button>
  </div>
</div>
  </div>
</div>

<!-- Cosmic visuals -->
<canvas id="stars"></canvas>
<div class="glow-veil"></div>

<!-- Corruption helpers -->
<div id="corruptOverlay" class="corrupt-overlay" aria-hidden="true"></div>
<div id="flash" class="flash" aria-hidden="true"></div>
<div id="buffer" class="buffer" role="dialog" aria-modal="true" aria-label="Buffering">
  <div class="buffer-card">
    <div style="font-weight:800; margin-bottom:8px">Reinitializing displayÃ¢â‚¬Â¦</div>
    <div class="bar" aria-hidden="true"><i id="barFill"></i></div>
    <div id="barPct" class="muted" style="margin-top:8px">0%</div>
  </div>
</div>
<div id="printMask" class="print-mask" aria-hidden="true"></div>
<div id="printLine" class="print-line" aria-hidden="true"></div>

<div class="wrap" id="appWrap">
  <!-- Header -->
  <div class="panel reveal">
    <h1 class="title">Smart Mail</h1>
    <div class="subtitle">Pick an intent. Or use Auto Detect.</div>

    <!-- Intent grid -->
    <div id="intentGrid" class="intent-grid"></div>

    <!-- Auto-detect stage -->
    <div id="autoStage" class="stage hidden">
      <div class="hr"></div>
      <div class="row">
        <div>
          <label for="to">To (Recipient)</label>
          <input id="to" type="email" placeholder="buyer@vendor.com" />
        </div>
        <div>
          <label for="subject">Subject (Draft)</label>
          <input id="subject" type="text" placeholder="RFQ PN-4812" />
        </div>
      </div>
      <div>
        <label for="hint">Body Hint (One or Two Lines)</label>
        <textarea id="hint" placeholder="Requesting pricing and lead time for PN-4812 quantity five"></textarea>
      </div>
      <div class="inline" style="margin:10px 0 6px">
        <span id="predStatus" class="muted"></span>
      </div>
      <div id="predInfo" class="inline" style="display:none;margin-top:6px">
        <span class="pill">Predicted: <b id="predIntent"></b></span>
        <span id="predBadge" class="pill"></span>
        <span id="predMsg" class="muted"></span>
      </div>
      <div id="topK" class="inline" style="gap:6px; flex-wrap:wrap; margin:8px 0 4px"></div>
    </div>
  </div>

  <!-- Fields -->
  <div class="panel reveal" style="margin-top:16px">
    <div class="inline">
      <h2 id="fieldsTitle" class="title" style="font-size:18px; margin:0">Fields</h2>
      <span class="subtitle" id="fieldsHint">(Select An Option Or Use Auto Detect)</span>
    </div>
    <div id="fields" class="kvs"></div>

    <div class="inline" style="margin:8px 0">
      <button id="btnGenerate" class="btn" type="button">Generate</button>
    </div>
  </div>

  <!-- Output -->
  <div class="panel reveal" style="margin-top:16px">
    <div class="inline">
      <h2 class="title" style="font-size:18px; margin:0">Output</h2>
      <span class="subtitle">Copy into your email client</span>
    </div>
    <div class="row">
      <div>
        <label>Subject</label>
        <div id="outSubject" class="out"></div>
        <div class="inline" style="margin-top:8px">
          <button id="copySubject" class="btn secondary">Copy Subject</button>
        </div>
      </div>
      <div>
        <label>Body</label>
        <div id="outBody" class="out"></div>
        <div class="inline" style="margin-top:8px">
          <button id="copyBody" class="btn secondary">Copy Body</button>
          <button id="btnClear" class="btn secondary">Clear</button>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
/* =========================================================================================
 * Smart Mail Template â€” Frontend Script (clean + documented)
 * =======================================================================================*/

function smartParseParts(raw){
  // Normalize line endings and separators
  const lines = String(raw || "")
    .replace(/\r/g, "")
    .split("\n")
    .map(s => s.trim())
    .filter(Boolean);

  const out = [];

  for (let line of lines){
    // common forms:
    // "PN-10423 x2", "PN-10423 2", "PN-10423,2", "PN-10423\t2"
    // allow "qty:2", "q=2", "(2)", "[2]"
    // default qty=1 when missing
    let pn = "";
    let qty = "";

    // Try comma/pipe/tab split first
    let hit = line.split(/[,\|\t]/).map(s => s.trim()).filter(Boolean);
    if (hit.length >= 2) {
      pn = hit[0];
      qty = hit[1];
    } else {
      // Try "something x2" or "something 2"
      const m = line.match(/^(.+?)\s*(?:x|qty[:=]|\(|\[)?\s*(\d+)[)\]]?\s*$/i);
      if (m) {
        pn = m[1].trim().replace(/\s+$/,"");
        qty = m[2].trim();
      } else {
        // No explicit qty -> default 1
        pn = line.trim();
        qty = "1";
      }
    }

    // sanitize
    pn = pn.replace(/\s{2,}/g, " ").trim();
    qty = String(qty || "1").trim();

    if (pn) out.push({ partNumber: pn, quantity: qty });
  }

  return out;
}

function syncPartsHidden(){
  const hidden = document.getElementById('f_parts');
  if(!hidden) return;

  const tbody = document.querySelector('#parts_table tbody');
  if(tbody){
    const rows = [...tbody.querySelectorAll('tr')].map(tr=>{
      const pn  = tr.querySelector('input[data-k="partNumber"]')?.value?.trim();
      const qty = tr.querySelector('input[data-k="quantity"]')?.value?.trim();
      return (pn && qty) ? { partNumber: pn, quantity: qty } : null;
    }).filter(Boolean);
    hidden.value = rows.length ? JSON.stringify(rows) : '[]';
  } else {
    const raw = document.getElementById('f_parts_text')?.value || '';
    const parsed = smartParseParts(raw);
    hidden.value = parsed.length ? JSON.stringify(parsed) : '[]';
  }
}

function addPartsRow(tbody, partNumber = "", quantity = ""){
  const tr = document.createElement('tr');
  tr.innerHTML = `
    <td><input class="input" data-k="partNumber" value="${partNumber}"></td>
    <td style="width:110px"><input class="input" data-k="quantity" value="${quantity}"></td>
    <td style="width:48px"><button type="button" class="btn-mini danger">âœ•</button></td>
  `;
tr.querySelectorAll('input').forEach(inp => {
  inp.addEventListener('input', (e)=>{
    if(e.target.dataset.k === 'quantity'){
      e.target.value = e.target.value.replace(/[^\d]/g,'');
    }
    syncPartsHidden();
  });
});
  tbody.appendChild(tr);
}



/* ===== Canvas: Starfield (subtle) ===== */
const Starfield = (function(){
  const c = document.getElementById('stars');
  const ctx = c.getContext('2d');
  const dpr = Math.min(2, window.devicePixelRatio || 1);
  let stars=[], rafId=null, running=false;
  function resize(){ c.width=innerWidth*dpr; c.height=innerHeight*dpr; ctx.setTransform(dpr,0,0,dpr,0,0); }
  function init(){
    stars = [];
    const count = Math.floor((innerWidth*innerHeight)/9000);
    for(let i=0;i<count;i++){
      stars.push({x:Math.random()*innerWidth, y:Math.random()*innerHeight, r:Math.random()*1.2+0.2, a:Math.random()*0.4+0.4, v:Math.random()*0.04+0.01});
    }
  }
  function draw(){
    if(!running) return;
    ctx.clearRect(0,0,innerWidth,innerHeight);
    stars.forEach(s=>{
      s.y+=s.v; if(s.y>innerHeight) s.y=-5;
      ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
      ctx.fillStyle=`rgba(200,230,255,${s.a})`; ctx.fill();
    });
    rafId = requestAnimationFrame(draw);
  }
  function start(){ if(running) return; running=true; resize(); init(); draw(); }
  function stop(){ running=false; if(rafId) cancelAnimationFrame(rafId); }
  addEventListener('resize', ()=>{ if(running){ resize(); init(); }});
  return { start, stop };
})();

/* ===== Tiny helpers ===== */
const $  = sel => document.querySelector(sel);
const $$ = sel => Array.from(document.querySelectorAll(sel));
const on = (el,ev,fn,opts)=> el && el.addEventListener(ev,fn,opts||false);
function delay(ms){ return new Promise(r => setTimeout(r, ms)); }

/* ===== DOM refs ===== */
const intentGrid   = document.getElementById('intentGrid') || document.getElementById('intentButtons') || document.querySelector('.intent-grid');
const fieldsWrap   = document.getElementById('fields')     || document.getElementById('fieldsWrap')    || document.querySelector('.kvs');
const fieldsHint   = document.getElementById('fieldsHint') || document.querySelector('#fieldsTitle + .subtitle');
const autoStage    = document.getElementById('autoStage');
const btnGenerate  = document.getElementById('btnGenerate');
const outSubject   = document.getElementById('outSubject');
const outBody      = document.getElementById('outBody');

/* ===== App state ===== */
let INTENTS = [];            // from /intents
let SELECTED_INTENT = '';    // '' or 'auto_detect' means auto-mode
let SCHEMA = {};             // from /schema

// NEW: Global defaults (session memory) + persistence key
let GLOBAL_DEFAULTS = { shipAddress: ''};
const DEFAULTS_STORAGE_KEY = 'sm_global_defaults_v1';

// Title helper (keep a single definition)
function toTitle(s){
  return (s || '')
    .replace(/([A-Z])/g, ' $1')
    .replace(/[_\-]+/g, ' ')
    .replace(/\s+/g, ' ')
    .trim()
    .replace(/^./, c=>c.toUpperCase());
}

/* ===== Networking ===== */
async function postJSON(url, data){
  const res = await fetch(url, {
    method: 'POST',
    headers: {'Content-Type':'application/json'},
    body: JSON.stringify(data)
  });
  if(!res.ok) throw new Error(`POST ${url} failed: ${res.status}`);
  return res.json();
}

async function loadSchema(){
  try{
    const res = await fetch('/schema');
    if(!res.ok) throw new Error('Failed to fetch /schema');
    SCHEMA = await res.json();
  }catch(e){
    console.error('Error loading /schema:', e);
    SCHEMA = {};
  }
}
/* ===== Global defaults helpers ===== */
function loadGlobalDefaults(){
  try{
    const raw = localStorage.getItem(DEFAULTS_STORAGE_KEY);
    if(raw){
      const parsed = JSON.parse(raw);
      if(parsed && typeof parsed === 'object'){
        GLOBAL_DEFAULTS = { ...GLOBAL_DEFAULTS, ...parsed };
      }
    }
  }catch(_e){}
  // Hydrate the settings UI
const a=$('#g_shipAddress');
if(a) a.value = GLOBAL_DEFAULTS.shipAddress || '';
}
function saveGlobalDefaults(){
  try{
    localStorage.setItem(DEFAULTS_STORAGE_KEY, JSON.stringify(GLOBAL_DEFAULTS));
  }catch(_e){}
}
function clearGlobalDefaults(persistToo){
  GLOBAL_DEFAULTS = { shipAddress:'', fedexAccount:'' };
  if(persistToo){ try{ localStorage.removeItem(DEFAULTS_STORAGE_KEY);}catch(_e){} }
  const a=$('#g_shipAddress'), f=$('#g_fedexAccount');
  if(a) a.value=''; if(f) f.value='';
}

/* ===== Date helpers ===== */
const DATE_KEYS = new Set([
  'dueDate','deliveryDate','shipDate','estimatedArrival','newDate',
  'pickupDate','dropoffDate','scheduleDate'
]);
function isDateKey(k){ return DATE_KEYS.has((k||'').toString()); }
function formatDateForOutput(yyyy_mm_dd){
  if(!yyyy_mm_dd) return '';
  const [y,m,d] = yyyy_mm_dd.split('-').map(x=>parseInt(x,10));
  if(!y||!m||!d) return '';
  const mm = String(m).padStart(2,'0');
  const dd = String(d).padStart(2,'0');
  const nowY = new Date().getFullYear();
  return (y === nowY) ? `${mm}/${dd}` : `${mm}/${dd}/${y}`;
}

/* =========================================================================================
 * Field rendering
 * =======================================================================================*/
function renderFields(intent){
  fieldsWrap.innerHTML = '';

  if(!intent || !SCHEMA || !SCHEMA[intent]){
    if(fieldsHint) fieldsHint.textContent = '';
    return;
  }

  const spec      = SCHEMA[intent];
  const required  = Array.isArray(spec.required) ? spec.required : [];
  const optional  = Array.isArray(spec.optional) ? spec.optional : [];
  const allKeys   = [...required, ...optional];
  const types     = spec.fieldTypes || {};
  const enums     = spec.enums || {};

  if(fieldsHint) fieldsHint.textContent = '';

  for(const key of allKeys){
    const wrap  = document.createElement('div');
    wrap.className = 'kv';

    const label = document.createElement('label');
    label.htmlFor = `f_${key}`;
    label.textContent = toTitle(key);

    wrap.appendChild(label);

    // Special case for 'parts'
    if (key === 'parts') {
      const host = document.createElement('div');
      host.id = 'partsCardBody';
      wrap.appendChild(host);
      fieldsWrap.appendChild(wrap);
      // mount the new inline editor (Part Number + Quantity with +/â€“ controls)
      initOrderRequestPartsEditor(host);
      continue;
    }

// Handle enum dropdowns dynamically (supports {label,value} and labels map fallback)
if (enums[key] && Array.isArray(enums[key]) && enums[key].length > 0) {
  const select = document.createElement('select');
  select.id = `f_${key}`;
  select.className = 'input';

  // labels map fallback from hints (e.g., hints.fedexAccountLabels)
  const labelsMap =
    (spec.hints && typeof spec.hints === 'object'
      && spec.hints[`${key}Labels`]) || {};

  enums[key].forEach(opt => {
    const o = document.createElement('option');

    // Case 1: generator already emits objects
    if (opt && typeof opt === 'object' && 'value' in opt) {
      o.value = String(opt.value);
      o.textContent = String(opt.label || opt.value);
    } else {
      // Case 2: enums are plain strings; use labelsMap if present
      const val = String(opt);
      o.value = val;
      o.textContent = labelsMap[val] ? String(labelsMap[val]) : val;
    }

    select.appendChild(o);
  });

  wrap.appendChild(select);
  fieldsWrap.appendChild(wrap);
  continue;
}

    // Normal input handling
    const t = String(types[key] || '').toLowerCase();
    if (t === 'date') {
      const input = document.createElement('input');
      input.type = 'date';
      input.id = `f_${key}`;
      input.className = 'input';
      wrap.appendChild(input);
    } else if (t === 'longtext') {
      const ta = document.createElement('textarea');
      ta.id = `f_${key}`;
      ta.rows = 4;
      ta.className = 'input';
      wrap.appendChild(ta);
    } else {
      const input = document.createElement('input');
      input.type = 'text';
      input.id = `f_${key}`;
      input.className = 'input';
      wrap.appendChild(input);
    }

    fieldsWrap.appendChild(wrap);
  }

  // Prefill shipAddress if global default exists
  const ga = (GLOBAL_DEFAULTS.shipAddress || '').trim();
  const shipAddrEl = fieldsWrap.querySelector('#f_shipAddress');
  if (shipAddrEl && !shipAddrEl.value && ga){
    shipAddrEl.value = ga;
  }

  const first = fieldsWrap.querySelector('input:not([type="hidden"]), select, textarea');
  if (first) first.focus();
}


function selectIntent(name){
  SELECTED_INTENT = name || '';
  if (!name || name === 'auto_detect'){
    autoStage?.classList.remove('hidden');
    renderFields(null);
  } else {
    autoStage?.classList.add('hidden');
    renderFields(name);
  }
  document.querySelectorAll('.intent-card')
    .forEach(card => card.classList.toggle('active', card.dataset.intent === name));
}
window.setSelectedIntent = selectIntent;


/* =========================================================================================
 * Intent grid (from backend)
 * =======================================================================================*/
function makeIntentCard(item){
  const div = document.createElement('div');
  div.className = 'intent-card';
  div.dataset.intent = item.name;

  const label = item.label || toTitle(item.name.replaceAll('_',' '));
  const desc  = item.description || '';

  div.innerHTML = `
    <div class="intent-name">${label}</div>
    <div class="intent-desc">${desc}</div>
  `;

  div.addEventListener('click', ()=>{
    const isActive = div.classList.contains('active');
    document.querySelectorAll('.intent-card').forEach(x=>x.classList.remove('active'));

    if(isActive){
      SELECTED_INTENT = '';
      renderFields(null);
      if (autoStage) autoStage.classList.add('hidden');
      return;
    }

    div.classList.add('active');

    if(item.name === 'auto_detect'){
      if (autoStage) autoStage.classList.remove('hidden');
      renderFields(null); // clear manual fields
      if (typeof window.setSelectedIntent === 'function') window.setSelectedIntent(null);
    } else {
      if (autoStage) autoStage.classList.add('hidden');
      selectIntent(item.name);
      if (typeof window.setSelectedIntent === 'function') window.setSelectedIntent(item.name);
    }
  });

  return div;
}

function renderIntentGridFromData(list){
  intentGrid.innerHTML = '';

  const visible = Array.isArray(list) ? list.filter(x => !x.hidden) : [];

  const normals = visible
    .filter(x => x.name !== 'auto_detect')
    .sort((a,b)=>{
      const ao = typeof a.order === 'number' ? a.order : 1_000_000;
      const bo = typeof b.order === 'number' ? b.order : 1_000_000;
      if (ao !== bo) return ao - bo;
      const al = (a.label || a.name).toLowerCase();
      const bl = (b.label || b.name).toLowerCase();
      return al.localeCompare(bl);
    });

  normals.forEach(x => intentGrid.appendChild(makeIntentCard(x)));

  const auto = visible.find(x => x.name === 'auto_detect');
  if (auto){
    const node = makeIntentCard(auto);
    node.style.background = 'linear-gradient(180deg, var(--card-bg1), var(--card-bg2))';
    intentGrid.appendChild(node);
  }
}

async function loadIntents(){
  try{
    const res = await fetch('/intents');
    if(!res.ok) throw new Error('Failed to fetch /intents');
    const data = await res.json();
    INTENTS = Array.isArray(data) ? data : [];
    renderIntentGridFromData(INTENTS);
  }catch(err){
    console.error('Error loading intents:', err);
    INTENTS = [];
    intentGrid.innerHTML = '';
  }
}


// === Order Request: Parts editor (Part Number + Quantity with inline +/â€“) ===

function initOrderRequestPartsEditor(container) {
// Clear and use the card itself (same as other fields)
container.innerHTML = "";
const cardBody = container;

// --- Label row (headers) ---
const header = document.createElement('div');
header.className = 'parts-header';

header.innerHTML = `
  <div class="h">Part<br>Number</div>
  <div class="h">Quantity</div>
  <div></div>
`;
cardBody.appendChild(header);

  // --- Table for rows ---
  const table = document.createElement('table');
  table.className = 'parts-rows';
  const tbody = document.createElement('tbody');
  table.appendChild(tbody);
cardBody.appendChild(table);

  // Hidden sink used elsewhere in your code (keep the same id if you had one)
  let hidden = container.querySelector('#partsHidden');
  if (!hidden) {
    hidden = document.createElement('textarea');
    hidden.id = 'partsHidden';
    hidden.style.display = 'none';
cardBody.appendChild(hidden);

  }

  // Local state: array of {partNumber, quantity}
  let parts = [];

  // Hydrate from any existing hidden value (supports list JSON)
  try {
    const v = JSON.parse(hidden.value || '[]');
    if (Array.isArray(v)) parts = v.map(r => ({
      partNumber: String(r.partNumber||''),
      quantity: String(r.quantity||'')
    }));
  } catch(_) { /* ignore */ }

  function syncPartsHidden(){
    // Keep only complete rows
    const rows = parts
      .map(r => ({ partNumber: (r.partNumber||'').trim(), quantity: (r.quantity||'').trim() }))
      .filter(r => r.partNumber && r.quantity);
    hidden.value = JSON.stringify(rows);
    // If your app has a global payload builder, it will read this hidden sink
  }

  function render(){
    tbody.innerHTML = '';

    // rows
parts.forEach((row, idx) => {
  const tr = document.createElement('tr');
  const td = document.createElement('td');
  td.colSpan = 3;

  const rowEl = document.createElement('div');
  rowEl.className = 'parts-row';

  // PN
  const pn = document.createElement('input');
  pn.className = 'input parts-input';
  pn.value = row.partNumber || '';
  pn.addEventListener('input', e => {
    parts[idx].partNumber = e.target.value;
    syncPartsHidden();
  });

  // Qty
  const qty = document.createElement('input');
  qty.className = 'input parts-input parts-qty';
  qty.inputMode = 'numeric';
  qty.value = row.quantity || '';
  qty.addEventListener('input', e => {
    e.target.value = e.target.value.replace(/[^\d]/g,'');
    parts[idx].quantity = e.target.value;
    syncPartsHidden();
  });
pn.placeholder = '';
qty.placeholder = '';

  // Minus
 const minus = document.createElement('button');
minus.type = 'button';
minus.className = 'icon-btn parts-minus';
minus.setAttribute('aria-label','Remove row');
minus.textContent = 'â€“';

  minus.addEventListener('click', () => {
    parts.splice(idx, 1);
    render();
    syncPartsHidden();
  });

  rowEl.appendChild(pn);
  rowEl.appendChild(qty);
  rowEl.appendChild(minus);
  td.appendChild(rowEl);
  tr.appendChild(td);
  tbody.appendChild(tr);
});

    // plus row (always exactly one, under the last existing row)
const trPlus = document.createElement('tr');
const tdPlus = document.createElement('td');
tdPlus.colSpan = 3;

const plusWrap = document.createElement('div');
plusWrap.className = 'parts-plus-row';
const plus = document.createElement('button');
plus.type = 'button';
plus.className = 'icon-btn parts-plus';
plus.setAttribute('aria-label','Add part');
plus.textContent = '+';

plus.addEventListener('click', () => {
  parts.push({ partNumber: '', quantity: '' });
  render();
  syncPartsHidden();
});

plusWrap.appendChild(plus);
tdPlus.appendChild(plusWrap);
trPlus.appendChild(tdPlus);
tbody.appendChild(trPlus);

  }

  // Seed with one row if none
  if (parts.length === 0) parts = [{ partNumber:'', quantity:'' }];
  render();
  syncPartsHidden();
}

// Hook into your existing page lifecycle
// Call this AFTER the intent card for "order_request" has been inserted into the DOM.
function enhanceOrderRequestCard() {
  // Find the Parts card DOM node â€“ adjust #partsCard selector to match your markup
  const card = document.querySelector('[data-field="parts"]') || document.querySelector('#partsCard') || null;
  if (card) initOrderRequestPartsEditor(card);
}

// If you already have a function that runs when the intent changes, call enhanceOrderRequestCard() there.
// Otherwise, run once on load (no-op for other intents).
document.addEventListener('DOMContentLoaded', () => {
  try { 
    if (typeof activeIntent !== 'undefined' && activeIntent === 'order_request') {
      enhanceOrderRequestCard();
    }
  } catch(_) {}
});

function listMissing(intentName, fieldsObj){
  const found = INTENTS.find(i => i.name === intentName);
  const req = found && Array.isArray(found.required) ? found.required : [];
  return req.filter(k => {
    const v = fieldsObj[k];
    if (Array.isArray(v)) return v.length === 0;
    if (v && typeof v === 'object') return Object.keys(v).length === 0;
    return String(v ?? '').trim() === '';
  });
}

function highlightMissing(keys){
  (keys || []).forEach(k=>{
    const el = document.getElementById(`f_${k}`);
    if(el && !el.value){
      el.style.boxShadow = '0 0 0 6px rgba(255,100,100,.12)';
      el.style.borderColor = 'rgba(255,100,100,.55)';
      setTimeout(()=>{ el.style.boxShadow=''; el.style.borderColor=''; }, 1200);
    }
  });
}
function collectFields(intent){
  const fields = {};
  document.querySelectorAll('#fields [id^="f_"]').forEach(el=>{
    const key = el.id.slice(2);
    if(!key) return;
    if(el.tagName === 'SELECT') fields[key] = el.value;
    else if(el.type === 'checkbox') fields[key] = !!el.checked;
    else fields[key] = el.value ?? '';
  });

  // Prefer hidden parts JSON (new editor uses #partsHidden; old table uses #f_parts)
  const partsHidden = document.getElementById('partsHidden') || document.getElementById('f_parts');
  if(partsHidden){
    try{
      const arr = JSON.parse(partsHidden.value || '[]');
      if(Array.isArray(arr)) fields.parts = arr;
    }catch(_){}
  }
  return fields;
}

async function doGenerate(){
  const btn = btnGenerate;

  try{
    if(btn){ btn.disabled = true; btn.setAttribute('aria-busy','true'); }

    const usingAuto = !SELECTED_INTENT || SELECTED_INTENT === 'auto_detect';

    // Build payload: ALWAYS send a string intent
    const intent = usingAuto ? 'auto_detect' : SELECTED_INTENT;
    if(!intent){
      if(fieldsHint) fieldsHint.textContent = ''; // invisible anyway
      return;
    }

    const fields = usingAuto ? {} : collectFields(intent);
    const payload = { intent, fields };
    const missing = listMissing(intent, fields);
    if(missing.length){
      console.warn('[Missing required fields]', missing);
      highlightMissing(missing);
    }

    const res = await fetch('/generate', {
      method:'POST',
      headers:{ 'Content-Type':'application/json', 'Accept':'application/json' },
      body: JSON.stringify(payload)
    });

    let data = null;
    try { data = await res.json(); } catch { /* ignore parse errors */ }

    if(!res.ok){
      const msg = (data && (data.detail || data.message)) ? `: ${data.detail || data.message}` : '';
      console.error('Generate failed:', res.status, data);
      if(fieldsHint) fieldsHint.textContent = ''; // keep hidden
      if(data){
        if(outSubject) outSubject.textContent = data.subject || '';
        if(outBody)    outBody.textContent    = data.body || '';
        if(Array.isArray(data.missing) && data.missing.length){
          console.warn('[Missing required fields]', data.missing);
          highlightMissing(data.missing);
        }
      }
      return;
    }

    const subject = data?.subject || '';
    const bodyRaw = data?.body || '';
    // Remove any leading "Subject:" line that came back in the body
    const body    = bodyRaw.replace(/^\s*subject\s*:\s*.*\n+/i,'');

    if(liveState.compose){
      await typeInto(outSubject, subject);
      await typeInto(outBody,    body);
    } else {
      if(outSubject) outSubject.textContent = subject;
      if(outBody)    outBody.textContent    = body;
    }

    // If backend tells us about missing fields, highlight them
    if(Array.isArray(data?.missing) && data.missing.length){
      console.warn('[Missing required fields]', data.missing);
      highlightMissing(data.missing);
    } else if(fieldsHint && intent !== 'auto_detect'){
      fieldsHint.textContent = '';
    }

  }catch(err){
    console.error('Generate crashed:', err);
    if(fieldsHint) fieldsHint.textContent = '';
  }finally{
    if(btn){ btn.disabled = false; btn.removeAttribute('aria-busy'); }
  }
}

on(btnGenerate, 'click', doGenerate);

document.getElementById('fields')?.addEventListener('keydown', (e)=>{
  if(e.key === 'Enter' && !e.shiftKey){
    e.preventDefault();
    doGenerate();
  }
});

// --- live toggles state + helpers ---
const liveState = {
  compose: false,   // #liveCompose
  preview: false,   // #livePreview
  tId: null         // debounce timer for auto-generate
};

function setLiveCompose(v){ liveState.compose = !!v; localStorage.setItem('sm_live_compose', liveState.compose ? '1':'0'); }
function setLivePreview(v){ liveState.preview = !!v; localStorage.setItem('sm_live_preview', liveState.preview ? '1':'0'); }

// simple typewriter effect for Output panel
async function typeInto(el, text){
  if(!el){ return; }
  el.textContent = '';
  const CHUNK = 3;
  for (let i = 0; i < text.length; i += CHUNK){
    const end = Math.min(i + CHUNK, text.length);
    el.textContent = text.slice(0, end);
    await new Promise(r => setTimeout(r, 8));
  }
  el.textContent = text; // guarantee no truncation
}

function scheduleLiveGenerate(delayMs=200){
  if(!liveState.preview) return;        // gate on toggle
  clearTimeout(liveState.tId);
  liveState.tId = setTimeout(()=> doGenerate(), delayMs);
}

// expose for predict code path that already calls these
window.scheduleLiveGenerate = scheduleLiveGenerate;




/* =========================================================================================
 * Settings menu + Theme + Typing toggles + Copy/Clear + Global Defaults wiring
 * =======================================================================================*/
(function wireUI(){
  const liveComposeCb = document.getElementById('liveCompose');
  const livePreviewCb = document.getElementById('livePreview');

  // restore saved state
  const savedCompose = localStorage.getItem('sm_live_compose') === '1';
  const savedPreview = localStorage.getItem('sm_live_preview') === '1';
  if(liveComposeCb){ liveComposeCb.checked = savedCompose; setLiveCompose(savedCompose); }
  if(livePreviewCb){ livePreviewCb.checked = savedPreview; setLivePreview(savedPreview); }
  if(btnGenerate){ btnGenerate.style.display = savedPreview ? 'none' : ''; }

  // wire toggles
  if(liveComposeCb){ liveComposeCb.addEventListener('change', e=> setLiveCompose(e.target.checked)); }
  if(livePreviewCb){
    livePreviewCb.addEventListener('change', e=>{
      setLivePreview(e.target.checked);
      if(btnGenerate){ btnGenerate.style.display = e.target.checked ? 'none' : ''; }
    });
  }

  // auto-generate when fields change (gated by livePreview)
  document.getElementById('fields')?.addEventListener('input', ()=>{
    scheduleLiveGenerate(250);
  });

  // also auto-generate if youâ€™re in Auto Detect draft area and they type
  document.getElementById('subject')?.addEventListener('input', ()=> scheduleLiveGenerate(300));
  document.getElementById('hint')?.addEventListener('input',    ()=> scheduleLiveGenerate(300));

  const settingsBtn  = document.querySelector('.settings-btn');
  const settingsMenu = document.querySelector('.settings-menu');
  const subTheme     = document.getElementById('subTheme');
  const subTyping    = document.getElementById('subTyping');
  const themeSelect  = document.getElementById('themeSelect');





const subDefaults = document.getElementById('subDefaults'); // add this near subTheme/subTyping

function closeAllSubs(){
  [subTheme, subTyping, subDefaults].forEach(el => el && el.classList.remove('open'));
  document.querySelectorAll('.settings-item .chev').forEach(c => c.classList.remove('rot90'));
}
function openOnly(which){
  closeAllSubs();
  if(which==='theme' && subTheme) subTheme.classList.add('open');
  if(which==='typing' && subTyping) subTyping.classList.add('open');
  if(which==='defaults' && subDefaults) subDefaults.classList.add('open');
  document.querySelectorAll('.settings-item').forEach(row=>{
    const chev = row.querySelector('.chev');
    if(!chev) return;
    chev.classList.toggle('rot90', row.getAttribute('data-item')===which);
  });
}




function toggleMenu(){
  const willOpen = !settingsMenu.classList.contains('open');
  settingsMenu.classList.toggle('open', willOpen);
  if(!willOpen) closeAllSubs();
  // reflect state for a11y
  const btn = document.getElementById('settingsBtn');
  if(btn) btn.setAttribute('aria-expanded', String(willOpen));
}

  on(settingsBtn,'click', (e)=>{ e.stopPropagation(); toggleMenu(); });
  on(settingsMenu,'click', (e)=>{
    const row = e.target.closest('.settings-item');
    if(!row) return;
    const which = row.getAttribute('data-item');
    if(which) openOnly(which);
  });
  on(document,'click', (e)=>{
    if(!settingsMenu.classList.contains('open')) return;
    const inside = settingsMenu.contains(e.target);
    const onBtn  = settingsBtn.contains(e.target);
    if(!inside && !onBtn){ settingsMenu.classList.remove('open'); closeAllSubs(); }
  });

  // Theme switching (persist in localStorage)
  const THEME_KEY = 'sm_theme';
  const saved = localStorage.getItem(THEME_KEY);
  if(saved){ document.body.dataset.theme = saved; }
  if(themeSelect){ themeSelect.value = document.body.dataset.theme || 'light-minimal'; }
  on(themeSelect, 'change', ()=>{
    const val = themeSelect.value || 'light-minimal';
    document.body.dataset.theme = val;
    localStorage.setItem(THEME_KEY, val);
    if(val==='cosmic') Starfield.start(); else Starfield.stop();
  });

  // --- Copy + Clear buttons (message + restore) ---
  const copySubjectBtn = document.getElementById('copySubject');
  const copyBodyBtn    = document.getElementById('copyBody');
  const clearBtn       = document.getElementById('btnClear');

  async function copyText(txt){
    try{ await navigator.clipboard.writeText(txt); }catch(e){ console.warn('Clipboard error', e); }
  }
  function flashBtn(btn, msg){
    if(!btn) return;
    const old = btn.textContent;
    btn.textContent = msg;
    btn.classList.add('toast');
    setTimeout(()=>{
      btn.classList.remove('toast');
      btn.textContent = old;
    }, 900);
  }

  if(copySubjectBtn){
    copySubjectBtn.addEventListener('click', ()=>{
      const txt = (outSubject?.textContent || '').trim();
      if(!txt){ flashBtn(copySubjectBtn, 'Copied'); return; } // keeps UX consistent
      copyText(txt);
      flashBtn(copySubjectBtn, 'Copied');
    });
  }
  if(copyBodyBtn){
    copyBodyBtn.addEventListener('click', ()=>{
      const txt = (outBody?.textContent || '').trim();
      if(!txt){ flashBtn(copyBodyBtn, 'Copied'); return; }
      copyText(txt);
      flashBtn(copyBodyBtn, 'Copied');
    });
  }
if(clearBtn){
  clearBtn.addEventListener('click', ()=>{
    if(outSubject) outSubject.textContent = '';
    if(outBody)    outBody.textContent = '';
    document.querySelectorAll('#fields input, #fields select, #fields textarea')
      .forEach(i=> i.value = '');
    flashBtn(clearBtn, 'Cleared');
  });
}

  /* ===== Global Defaults wiring ===== */
  loadGlobalDefaults(); // hydrate Settings UI with saved values (if any)

  const gAddr  = document.getElementById('g_shipAddress');
  const gAcct  = document.getElementById('g_fedexAccount');
  const gSave  = document.getElementById('g_save');
  const gApply = document.getElementById('g_apply');
  const gClear = document.getElementById('g_clear');

  function captureDefaultsFromUI(){
    GLOBAL_DEFAULTS.shipAddress  = (gAddr?.value || '').trim();
  }

  if(gApply){
    gApply.addEventListener('click', ()=>{
      captureDefaultsFromUI();
      if(gSave?.checked) saveGlobalDefaults();
      // Re-render fields for current intent so defaults prefill immediately
      if(SELECTED_INTENT){ renderFields(SELECTED_INTENT); }
    });
  }

  if(gClear){
    gClear.addEventListener('click', ()=>{
      const persist = !!gSave?.checked;
      clearGlobalDefaults(persist);
      if(SELECTED_INTENT){ renderFields(SELECTED_INTENT); }
    });
  }
})();







/* =========================================================================================
 * Corruption / â€œprinter reloadâ€ easter egg (preserved)
 * =======================================================================================*/
async function runCorruption(){
  document.body.classList.add('corrupting');
  Starfield.stop();

  const bufferEl  = document.getElementById('buffer');
  const printMask = document.getElementById('printMask');
  const printLine = document.getElementById('printLine');

  if(bufferEl)  bufferEl.classList.add('show');
  await delay(900);
  if(bufferEl)  bufferEl.classList.remove('show');

  if(printMask) printMask.classList.add('show');
  if(printLine) printLine.classList.add('show');

  $$('.panel').forEach(p=> p.style.opacity = '0');
  await delay(2600);

  if(printMask) printMask.classList.remove('show');
  if(printLine) printLine.classList.remove('show');

  $$('.panel').forEach((p,i)=> setTimeout(()=> p.style.opacity = '1', 60*i));

  document.body.classList.remove('corrupting');
  if(document.body.dataset.theme === 'cosmic') Starfield.start();
}

/* =========================================================================================
 * Init (modernized for YAML schema)
 * =======================================================================================*/
(async function init(){
  document.body.setAttribute('data-theme', document.body.getAttribute('data-theme') || 'light-minimal');
  if(document.body.dataset.theme === 'cosmic') Starfield.start();

  try {
    // Fetch generated schema
    const schemaRes = await fetch('/schema');
    if (!schemaRes.ok) throw new Error('Failed to load schema');
    SCHEMA = await schemaRes.json();

    // Fetch compact intent list for cards
    const intentsRes = await fetch('/intents');
    if (!intentsRes.ok) throw new Error('Failed to load intents');
    const data = await intentsRes.json();

    // Render cards dynamically from schema/intents
if (Array.isArray(data) && data.length) {
  // Include auto_detect
  INTENTS = data.map(x => ({
    name: x.id || x.name,
    label: x.label || (x.id ? toTitle(x.id) : ''),
    description: SCHEMA[x.id || x.name]?.description || '',
    required: SCHEMA[x.id || x.name]?.required || [],
    hidden: false
  }));
  // Put Auto Detect first
  INTENTS.sort((a, b) => (a.name === 'auto_detect' ? -1 : b.name === 'auto_detect' ? 1 : a.label.localeCompare(b.label)));
} else {
  // No /intents endpoint or empty â†’ build from schema directly
  INTENTS = Object.keys(SCHEMA).map(k => ({
    name: k,
    label: SCHEMA[k].label || toTitle(k),
    description: SCHEMA[k].description || '',
    required: SCHEMA[k].required || [],
    hidden: false
  }));
  INTENTS.sort((a, b) => (a.name === 'auto_detect' ? -1 : b.name === 'auto_detect' ? 1 : a.label.localeCompare(b.label)));
}

    renderIntentGridFromData(INTENTS);
  } catch (err) {
    console.error('Error initializing schema/intents:', err);
    intentGrid.innerHTML = '<div class="muted">Failed to load schema.</div>';
  }

  if (fieldsHint) fieldsHint.textContent = ''; // invisible by design
})();
</script>

<script>window.EVIL_LARRY_SRC = 'img/evil-larry.png';</script>

<!-- Evil Larry (RAIN MODE) -->
<style>
  .evil-larry{
    position:fixed; left:0; top:0;
    width:420px; height:420px;
    z-index:9999;
    pointer-events:none; will-change:transform,opacity;
    transform:translate(-50%,-420px) rotate(0deg);
    filter: drop-shadow(0 20px 50px rgba(0,0,0,.55));
  }
  .evil-larry img{
    display:block; width:100%; height:100%;
    object-fit:contain; user-select:none; font-size:0;
  }
  @media (max-width:520px){
    .evil-larry{ width:260px; height:260px; transform:translate(-50%,-260px) rotate(0deg); }
  }

/* make Parts inputs follow theme text color */
.parts-input {
  color: inherit;                /* match surrounding theme text */
  background: transparent;
  border: 1px solid var(--card-border, rgba(255,255,255,.1));
  border-radius: 12px;
  height: 44px;
  width: 100%;
  transition: border-color 0.2s ease, box-shadow 0.2s ease;
}
.parts-input:focus {
  border-color: var(--accent, #639cff);
  box-shadow: 0 0 0 2px rgba(99,156,255,.25);
  outline: none;
}
.parts-input::placeholder {
  color: transparent;            /* ensures hidden placeholder stays hidden */
}

/* ensure icons stay visible in both modes */
.icon-btn.parts-plus,
.icon-btn.parts-minus {
  background: var(--card-bg2, #fff);
  color: inherit;
}

</style>

<script>
/* Larry Storm: spawn 1 (Shift+L) or a rain of Larrys (type "larry") */
(function(){
  const IMG_SRC = window.EVIL_LARRY_SRC || 'https://placekitten.com/256/256';
  const COOLDOWN_SINGLE_MS = 1500;
  const COOLDOWN_RAIN_MS   = 8000;

  let lastSingle = 0, lastRain = 0;

  (new Image()).src = IMG_SRC;

  const sprites = new Set();
  let rafId = null;

  function startLoop(){
    if (rafId) return;
    let W = innerWidth, H = innerHeight;
    function fit(){ W = innerWidth; H = innerHeight; }
    addEventListener('resize', fit, { passive:true });

    function frame(ts){
      if (sprites.size === 0){ rafId = null; return; }
      sprites.forEach(s => {
        s.vy += s.g;
        s.x  += s.vx;
        s.y  += s.vy;
        s.a  += s.spin;

        if (s.x <= 0){ s.x = 0; s.vx = Math.abs(s.vx); s.spin = -s.spin; }
        if (s.x >= W - s.size){ s.x = W - s.size; s.vx = -Math.abs(s.vx); s.spin = -s.spin; }
        if (s.y >= H - s.size){ s.y = H - s.size; s.vy = -Math.abs(s.vy) * s.damp; }

        s.el.style.transform = `translate(${s.x}px,${s.y}px) rotate(${s.a}deg)`;

        if (ts - s.t0 > s.life){
          s.el.style.transition = 'transform 1.1s cubic-bezier(.2,.8,.2,1), opacity .9s ease';
          s.el.style.opacity = '0';
          s.el.style.transform = `translate(${s.x}px,-${s.size + 100}px) rotate(${s.a + 720}deg)`;
          setTimeout(()=>{ s.el.remove(); sprites.delete(s); }, 1200);
        }
      });
      rafId = requestAnimationFrame(frame);
    }
    rafId = requestAnimationFrame(frame);
  }

  function spawnOne(opts = {}){
    const el = document.createElement('div');
    el.className = 'evil-larry';
    el.innerHTML = `<img alt="Evil Larry" referrerpolicy="no-referrer" src="${IMG_SRC}">`;
    document.body.appendChild(el);

    const base = el.getBoundingClientRect().width || 420;
    const scale = opts.scale ?? (0.6 + Math.random()*0.9);
    el.style.transformOrigin = 'center';
    el.style.width  = (base*scale) + 'px';
    el.style.height = (base*scale) + 'px';

    const W = innerWidth, H = innerHeight;
    const size = base * scale;

    const x0 = Math.random() * Math.max(10, W - size - 10);
    const y0 = -size - 40 - Math.random()*120;

    const vx = (Math.random()<0.5?-1:1) * (2 + Math.random()*3);
    const vy = 2 + Math.random()*2;
    const g  = 0.16 + Math.random()*0.08;
    const spin = (Math.random()<0.5?-1:1) * (2.5 + Math.random()*3.5);
    const damp = 0.84 + Math.random()*0.07;

    const s = {
      el, size,
      x:x0, y:y0, vx, vy, g, a:0, spin, damp,
      t0: performance.now(),
      life: (opts.lifeMs ?? (4800 + Math.random()*3000))
    };

    sprites.add(s);
    startLoop();
  }

  function runEvilLarry(){ const now = Date.now(); if (now - lastSingle < COOLDOWN_SINGLE_MS) return; lastSingle = now; spawnOne({ scale: 1 }); }
  function runEvilLarryRain(count = 24){
    const now = Date.now(); if (now - lastRain < COOLDOWN_RAIN_MS) return; lastRain = now;
    const n = Math.max(4, Math.min(64, count));
    for (let i=0; i<n; i++){
      setTimeout(()=> spawnOne({
        scale: 0.6 + Math.random()*1.2,
        lifeMs: 4200 + Math.random()*3500
      }), Math.random()*900);
    }
  }

  window.runEvilLarry = runEvilLarry;
  window.runEvilLarryRain = runEvilLarryRain;

  document.addEventListener('keydown', (e)=>{
    if (e.metaKey || e.ctrlKey || e.altKey) return;
    if ((e.key||'').toLowerCase() === 'l' && e.shiftKey) runEvilLarry();
  });

  const WORD = 'larry'; let seq = []; let lastTs = 0; const MAX_GAP_MS = 3000;
  document.addEventListener('keydown', (e)=>{
    if (e.metaKey || e.ctrlKey || e.altKey) return;
    const k = (e.key||'').toLowerCase();
    if (!/^[a-z]$/.test(k)) return;
    const now = Date.now();
    if (now - lastTs > MAX_GAP_MS) seq = [];
    lastTs = now; seq.push(k); if (seq.length > WORD.length) seq.shift();
    if (seq.join('') === WORD){ runEvilLarryRain(28); seq = []; }
  });
})();
</script>

<script>
/* === Live Auto-Detect on Hint typing (resilient + correct payload) === */
(function(){
  const $ = (s)=>document.querySelector(s);
  const THR = (typeof window.CONF_THR === 'number' ? window.CONF_THR : 0.55);

  let currentHintEl = null;
  let debounceTimer = null;
  let inflight = null;

  const els = {
    to:         $('#to'),
    subject:    $('#subject'),
    predStatus: $('#predStatus'),
    predInfo:   $('#predInfo'),
    predIntent: $('#predIntent'),
    predBadge:  (function(){
                  let n = document.getElementById('predBadge');
                  if(!n){
                    n = document.createElement('span');
                    n.id = 'predBadge';
                    n.className = 'pill';
                    document.getElementById('predInfo')?.appendChild(n);
                  }
                  return n;
                })(),
    predMsg:    $('#predMsg'),
    topK:       $('#topK'),
    btnPredict: $('#btnPredict')
  };



    const toNice = (s)=> (s||'').replaceAll('_',' ').split(' ').map(w=>w.charAt(0).toUpperCase()+w.slice(1).toLowerCase()).join(' ');
    function scoreBadge(score){ return `${Math.round((score ?? 0)*100)}%`; }
    function setPredictStatus(msg){ if(els.predStatus) els.predStatus.textContent = msg || ''; }
    function hidePredictInfo(){ if(els.predInfo) els.predInfo.style.display='none'; if(els.topK) els.topK.innerHTML=''; }

    function updatePredictUI(data){
    if(!data){ hidePredictInfo(); return; }
    const { intent, confidence, top_k = [], message = '' } = data;

    if(els.predIntent) els.predIntent.textContent = intent ? toNice(intent) : 'â€”';
    if(els.predBadge)  els.predBadge.textContent  = scoreBadge(confidence ?? 0);

    if(els.predMsg)    els.predMsg.textContent    = message || '';

    if(els.topK){
      els.topK.innerHTML = '';
      top_k.forEach(item=>{
        const name = Array.isArray(item) ? item[0] : (item.label || item.intent || '');
        const score = Array.isArray(item) ? item[1] : (item.score ?? 0);
        const b = document.createElement('button');
        b.className = 'btn secondary';
        b.textContent = `${toNice(name)} (${Math.round((score??0)*100)}%)`;
        b.addEventListener('click', ()=>{
          document.querySelectorAll('.intent-card').forEach(x=>x.classList.remove('active'));
          const targetName = toNice(name);
          [...document.querySelectorAll('.intent-card')].find(x=>x.querySelector('.intent-name')?.textContent===targetName)?.classList.add('active');
          if (typeof window.setSelectedIntent === 'function') window.setSelectedIntent(name);

          setTimeout(()=>{
            const hintNow = (document.getElementById('hint')?.value || '').trim();
            if (hintNow) window.autoPopulateFields?.(name, hintNow);
            window.scheduleLiveGenerate?.();
          }, 60);

          window.scrollTo({ top: document.body.scrollHeight/3, behavior: 'smooth' });
        });
        els.topK.appendChild(b);
      });
    }
    if(els.predInfo) els.predInfo.style.display='flex';

    if (data?.intent && typeof window.setSelectedIntent === 'function') {
      window.setSelectedIntent(data.intent);
      setTimeout(()=>{
        const hintNow = (document.getElementById('hint')?.value || '').trim();
        if (hintNow) window.autoPopulateFields?.(data.intent, hintNow);
        window.scheduleLiveGenerate?.();
      }, 60);
    }
  }

  async function predictNow(hintVal){
    if(inflight){ try{ inflight.abort(); }catch{} }
    inflight = new AbortController();

    const payload = {
      to: (els.to?.value || '').trim(),
      subject: (els.subject?.value || '').trim(),
      body_hint: hintVal
    };

    setPredictStatus('Predictingâ€¦');
    try{
      const res = await fetch('/predict', {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify(payload),
        signal: inflight.signal
      });
      const data = await res.json();
      updatePredictUI(data);
      setPredictStatus('');
    }catch(err){
      if(err?.name === 'AbortError') return;
      setPredictStatus('Prediction failed.');
      hidePredictInfo();
    }
  }

  function onType(){
    if(!currentHintEl) return;
    const hint = (currentHintEl.value || '').trim();
    if(!hint){ setPredictStatus(''); hidePredictInfo(); return; }
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(()=>predictNow(hint), 150);
  }

  function attachToHint(el){
    if(currentHintEl === el) return;
    if(currentHintEl) currentHintEl.removeEventListener('input', onType);
    currentHintEl = el;
    if(currentHintEl) currentHintEl.addEventListener('input', onType, {passive:true});
  }

  attachToHint($('#hint'));
  const mo = new MutationObserver(()=> attachToHint($('#hint')));
  mo.observe(document.body, {childList:true, subtree:true});

  if(els.btnPredict){
    els.btnPredict.addEventListener('click', (e)=>{
      e.preventDefault();
      const el = $('#hint'); attachToHint(el);
      const hint = (el?.value || '').trim();
      if(!hint){ setPredictStatus(''); hidePredictInfo(); return; }
      predictNow(hint);
    });
  }
})();
</script>
</body>
</html>

